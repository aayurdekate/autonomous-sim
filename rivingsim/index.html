<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Autonomous Vehicle Simulator</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    #container {
      position: relative;
      width: 100%;
      height: 100vh;
    }
    
    #webglCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    
    #searchBox {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      z-index: 100;
      width: 300px;
    }
    
    #destination {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    
    button {
      padding: 8px 15px;
      margin-right: 10px;
      cursor: pointer;
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 3px;
    }
    
    button:hover {
      background: #3367d6;
    }
    
    #speedometer {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    
    #destinationList {
      list-style-type: none;
      padding: 0;
      margin-top: 10px;
    }
    
    #destinationList li {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    
    #destinationList li:hover {
      background-color: #f0f0f0;
    }
    
    #miniMap {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 5px;
      z-index: 100;
      overflow: hidden;
    }
    
    #miniMapCanvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="webglCanvas"></canvas>
    
    <div id="searchBox">
      <input type="text" id="destination" placeholder="Enter destination...">
      <button id="goButton">Go</button>
      <button id="toggleModeButton">Switch to Manual</button>
      <ul id="destinationList"></ul>
    </div>
    
    <div id="controls">
      <button id="forwardButton">Forward</button>
      <button id="backButton">Back</button>
      <button id="leftButton">Left</button>
      <button id="rightButton">Right</button>
      <button id="resetButton">Reset</button>
    </div>
    
    <div id="speedometer">
      <div>Speed: <span id="speed">0</span> km/h</div>
      <div>Mode: <span id="mode">Autonomous</span></div>
    </div>
    
    <div id="miniMap">
      <canvas id="miniMapCanvas"></canvas>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
  <script>
    // Main application
    const App = {
      // Configuration
      config: {
        roadWidth: 10,
        citySize: 500,
        blockSize: 80,
        buildingMaxHeight: 50,
        carSpeed: 0.5,
        trafficDensity: 20, // Number of AI cars
        treeDensity: 50,   // Number of trees
        laneWidth: 5,      // Width of each lane (half of road width)
      },
      
      // Application state
      state: {
        isAutonomousMode: true,
        isMoving: false,
        currentDestination: null,
        currentPath: [],
        currentPathIndex: 0,
        keyStates: {},
        carSpeed: 0,
        cars: [],
        intersections: [],
        buildings: [],
        trees: [],
        loadingProgress: 0,
        frameCount: 0,
      },
      
      // Initialize the application
      init: function() {
        this.setupScene();
        this.setupLights();
        this.setupControls();
        this.createCity();
        this.createMainCar();
        this.createTraffic();
        this.createTrees();
        this.setupDestinations();
        this.setupMiniMap();
        this.animate();
      },
      
      // Set up Three.js scene
      setupScene: function() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
        
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 50, 50);
        this.camera.lookAt(0, 0, 0);
        
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webglCanvas'), antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        
        // Handle window resize
        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Create a ground plane
        const groundGeometry = new THREE.PlaneGeometry(this.config.citySize * 2, this.config.citySize * 2);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1e824c, roughness: 0.8 }); // Grass color
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.scene.add(ground);
      },
      
      // Set up lights
      setupLights: function() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        
        // Directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -200;
        directionalLight.shadow.camera.right = 200;
        directionalLight.shadow.camera.top = 200;
        directionalLight.shadow.camera.bottom = -200;
        this.scene.add(directionalLight);
      },
      
      // Set up user controls
      setupControls: function() {
        // Mode toggle button
        document.getElementById('toggleModeButton').addEventListener('click', () => {
          this.state.isAutonomousMode = !this.state.isAutonomousMode;
          document.getElementById('toggleModeButton').textContent = 
            this.state.isAutonomousMode ? 'Switch to Manual' : 'Switch to Autonomous';
          document.getElementById('mode').textContent = 
            this.state.isAutonomousMode ? 'Autonomous' : 'Manual';
            
          // Show/hide manual controls
          document.getElementById('controls').style.display = 
            this.state.isAutonomousMode ? 'none' : 'block';
        });
        
        // Initially hide manual controls
        document.getElementById('controls').style.display = 'none';
        
        // Go button
        document.getElementById('goButton').addEventListener('click', this.handleDestinationSelection.bind(this));
        
        // Add debug button to force autonomous mode
        const debugButton = document.createElement('button');
        debugButton.textContent = 'Force Autonomous Mode';
        debugButton.style.position = 'fixed';
        debugButton.style.bottom = '10px';
        debugButton.style.right = '10px';
        debugButton.style.zIndex = '1000';
        debugButton.addEventListener('click', () => {
          this.state.isAutonomousMode = true;
          this.state.isMoving = true;
          document.getElementById('toggleModeButton').textContent = 'Switch to Manual';
          document.getElementById('mode').textContent = 'Autonomous';
          document.getElementById('controls').style.display = 'none';
          console.log('Forced autonomous mode:', this.state.isAutonomousMode, 'isMoving:', this.state.isMoving);
        });
        document.body.appendChild(debugButton);
        
        // Manual control buttons
        document.getElementById('forwardButton').addEventListener('mousedown', () => this.state.keyStates['ArrowUp'] = true);
        document.getElementById('forwardButton').addEventListener('mouseup', () => this.state.keyStates['ArrowUp'] = false);
        document.getElementById('backButton').addEventListener('mousedown', () => this.state.keyStates['ArrowDown'] = true);
        document.getElementById('backButton').addEventListener('mouseup', () => this.state.keyStates['ArrowDown'] = false);
        document.getElementById('leftButton').addEventListener('mousedown', () => this.state.keyStates['ArrowLeft'] = true);
        document.getElementById('leftButton').addEventListener('mouseup', () => this.state.keyStates['ArrowLeft'] = false);
        document.getElementById('rightButton').addEventListener('mousedown', () => this.state.keyStates['ArrowRight'] = true);
        document.getElementById('rightButton').addEventListener('mouseup', () => this.state.keyStates['ArrowRight'] = false);
        document.getElementById('resetButton').addEventListener('click', this.resetSimulation.bind(this));
        
        // Keyboard controls
        window.addEventListener('keydown', (e) => {
          if (!this.state.isAutonomousMode) {
            this.state.keyStates[e.key] = true;
          }
        });
        
        window.addEventListener('keyup', (e) => {
          this.state.keyStates[e.key] = false;
        });
      },
      
      // Create the city layout
      createCity: function() {
        // Create a grid of city blocks with roads between them
        const halfCity = this.config.citySize / 2;
        const blockSize = this.config.blockSize;
        const roadWidth = this.config.roadWidth;
        
        // Create road material
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.7 });
        
        // Create horizontal roads
        for (let z = -halfCity; z <= halfCity; z += blockSize + roadWidth) {
          const roadGeometry = new THREE.PlaneGeometry(this.config.citySize * 2, roadWidth);
          const road = new THREE.Mesh(roadGeometry, roadMaterial);
          road.rotation.x = -Math.PI / 2;
          road.position.set(0, 0.1, z);
          road.receiveShadow = true;
          this.scene.add(road);
          
          // Add road markings (center line)
          const centerLineGeometry = new THREE.PlaneGeometry(this.config.citySize * 2, 0.5);
          const centerLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
          centerLine.rotation.x = -Math.PI / 2;
          centerLine.position.set(0, 0.11, z);
          this.scene.add(centerLine);
          
          // Add lane markings (dashed lines)
          this.addLaneMarkings(0, z, true); // Horizontal road
        }
        
        // Create vertical roads
        for (let x = -halfCity; x <= halfCity; x += blockSize + roadWidth) {
          const roadGeometry = new THREE.PlaneGeometry(roadWidth, this.config.citySize * 2);
          const road = new THREE.Mesh(roadGeometry, roadMaterial);
          road.rotation.x = -Math.PI / 2;
          road.position.set(x, 0.1, 0);
          road.receiveShadow = true;
          this.scene.add(road);
          
          // Add road markings (center line)
          const centerLineGeometry = new THREE.PlaneGeometry(0.5, this.config.citySize * 2);
          const centerLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
          centerLine.rotation.x = -Math.PI / 2;
          centerLine.position.set(x, 0.11, 0);
          this.scene.add(centerLine);
          
          // Add lane markings (dashed lines)
          this.addLaneMarkings(x, 0, false); // Vertical road
        }
        
        // Create buildings on city blocks
        for (let x = -halfCity + blockSize/2; x < halfCity; x += blockSize + roadWidth) {
          for (let z = -halfCity + blockSize/2; z < halfCity; z += blockSize + roadWidth) {
            this.createBuilding(x, z);
          }
        }
        
        // Track all intersections for navigation
        for (let x = -halfCity; x <= halfCity; x += blockSize + roadWidth) {
          for (let z = -halfCity; z <= halfCity; z += blockSize + roadWidth) {
            this.state.intersections.push({ x, z });
            
            // Visual marker for debug (small cylinder at each intersection)
            /*
            const markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.5, z);
            this.scene.add(marker);
            */
          }
        }
      },
      
      // Add lane markings to roads
      addLaneMarkings: function(x, z, isHorizontal) {
        const halfCity = this.config.citySize / 2;
        const laneWidth = this.config.laneWidth;
        const dashLength = 3;
        const dashGap = 3;
        const dashWidth = 0.5;
        const dashMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        if (isHorizontal) {
          // Horizontal road lane markings
          const totalLength = this.config.citySize * 2;
          const numDashes = Math.floor(totalLength / (dashLength + dashGap));
          
          for (let i = 0; i < numDashes; i++) {
            const dashX = -halfCity + i * (dashLength + dashGap) + dashLength / 2;
            
            // Left lane marking
            const leftDashGeometry = new THREE.PlaneGeometry(dashLength, dashWidth);
            const leftDash = new THREE.Mesh(leftDashGeometry, dashMaterial);
            leftDash.rotation.x = -Math.PI / 2;
            leftDash.position.set(dashX, 0.12, z - laneWidth / 2);
            this.scene.add(leftDash);
            
            // Right lane marking
            const rightDashGeometry = new THREE.PlaneGeometry(dashLength, dashWidth);
            const rightDash = new THREE.Mesh(rightDashGeometry, dashMaterial);
            rightDash.rotation.x = -Math.PI / 2;
            rightDash.position.set(dashX, 0.12, z + laneWidth / 2);
            this.scene.add(rightDash);
          }
        } else {
          // Vertical road lane markings
          const totalLength = this.config.citySize * 2;
          const numDashes = Math.floor(totalLength / (dashLength + dashGap));
          
          for (let i = 0; i < numDashes; i++) {
            const dashZ = -halfCity + i * (dashLength + dashGap) + dashLength / 2;
            
            // Left lane marking
            const leftDashGeometry = new THREE.PlaneGeometry(dashWidth, dashLength);
            const leftDash = new THREE.Mesh(leftDashGeometry, dashMaterial);
            leftDash.rotation.x = -Math.PI / 2;
            leftDash.position.set(x - laneWidth / 2, 0.12, dashZ);
            this.scene.add(leftDash);
            
            // Right lane marking
            const rightDashGeometry = new THREE.PlaneGeometry(dashWidth, dashLength);
            const rightDash = new THREE.Mesh(rightDashGeometry, dashMaterial);
            rightDash.rotation.x = -Math.PI / 2;
            rightDash.position.set(x + laneWidth / 2, 0.12, dashZ);
            this.scene.add(rightDash);
          }
        }
      },
      
      // Create a building at the specified position
      createBuilding: function(x, z) {
        const width = 10 + Math.random() * 20;
        const depth = 10 + Math.random() * 20;
        const height = 10 + Math.random() * this.config.buildingMaxHeight;
        
        // Ensure buildings don't extend beyond their block
        const adjustedX = Math.max(Math.min(x, x + width/2), x - width/2);
        const adjustedZ = Math.max(Math.min(z, z + depth/2), z - depth/2);
        
        // Building body
        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
        
        // Random building color
        const buildingColors = [0xb2b2b2, 0x8c8c8c, 0x4c4c4c, 0xe6e6e6, 0xb3d9ff, 0xf2f2f2];
        const buildingColor = buildingColors[Math.floor(Math.random() * buildingColors.length)];
        
        const buildingMaterial = new THREE.MeshStandardMaterial({ 
          color: buildingColor,
          roughness: 0.7,
          metalness: 0.2
        });
        
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.set(adjustedX, height/2, adjustedZ);
        building.castShadow = true;
        building.receiveShadow = true;
        
        this.scene.add(building);
        this.state.buildings.push(building);
        
        // Add window grid pattern
        this.addBuildingWindows(building, width, height, depth);
        
        return building;
      },
      
      // Add windows to a building
      addBuildingWindows: function(building, width, height, depth) {
        const windowMaterial = new THREE.MeshBasicMaterial({ color: 0xffee88 });
        const windowSize = 1.5;
        const windowDepth = 0.1;
        const windowSpacing = 3;
        
        // Add windows on front side
        for (let y = 2; y < height - 2; y += windowSpacing) {
          for (let x = -width/2 + 2; x < width/2 - 2; x += windowSpacing) {
            if (Math.random() > 0.3) { // Some windows are off
              const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, windowDepth);
              const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
              windowMesh.position.set(x, y, depth/2 + 0.1);
              building.add(windowMesh);
            }
          }
        }
        
        // Add windows on back side
        for (let y = 2; y < height - 2; y += windowSpacing) {
          for (let x = -width/2 + 2; x < width/2 - 2; x += windowSpacing) {
            if (Math.random() > 0.3) {
              const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, windowDepth);
              const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
              windowMesh.position.set(x, y, -depth/2 - 0.1);
              building.add(windowMesh);
            }
          }
        }
        
        // Add windows on left side
        for (let y = 2; y < height - 2; y += windowSpacing) {
          for (let z = -depth/2 + 2; z < depth/2 - 2; z += windowSpacing) {
            if (Math.random() > 0.3) {
              const windowGeometry = new THREE.BoxGeometry(windowDepth, windowSize, windowSize);
              const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
              windowMesh.position.set(-width/2 - 0.1, y, z);
              building.add(windowMesh);
            }
          }
        }
        
        // Add windows on right side
        for (let y = 2; y < height - 2; y += windowSpacing) {
          for (let z = -depth/2 + 2; z < depth/2 - 2; z += windowSpacing) {
            if (Math.random() > 0.3) {
              const windowGeometry = new THREE.BoxGeometry(windowDepth, windowSize, windowSize);
              const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
              windowMesh.position.set(width/2 + 0.1, y, z);
              building.add(windowMesh);
            }
          }
        }
      },
      
      // Create the main car (user's vehicle)
      createMainCar: function() {
        // Create a car group
        this.mainCar = new THREE.Group();
        
        // Car body
        const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 7);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.7 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.5;
        body.castShadow = true;
        this.mainCar.add(body);
        
        // Car cabin/roof
        const cabinGeometry = new THREE.BoxGeometry(3.5, 1.2, 4);
        const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.7 });
        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
        cabin.position.set(0, 2.85, -0.5);
        cabin.castShadow = true;
        this.mainCar.add(cabin);
        
        // Windshield
        const windshieldGeometry = new THREE.BoxGeometry(3.3, 1, 0.1);
        const windshieldMaterial = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.7 });
        const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
        windshield.position.set(0, 2.85, 1.45);
        this.mainCar.add(windshield);
        
        // Back windshield
        const backWindshieldGeometry = new THREE.BoxGeometry(3.3, 1, 0.1);
        const backWindshield = new THREE.Mesh(backWindshieldGeometry, windshieldMaterial);
        backWindshield.position.set(0, 2.85, -2.45);
        this.mainCar.add(backWindshield);
        
        // Wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16);
        const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        
        const wheelPositions = [
          [-1.8, 0.7, 2.5],  // Front left
          [1.8, 0.7, 2.5],   // Front right
          [-1.8, 0.7, -2.5], // Back left
          [1.8, 0.7, -2.5]   // Back right
        ];
        
        wheelPositions.forEach(position => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(...position);
          wheel.castShadow = true;
          this.mainCar.add(wheel);
        });
        
        // Position car on a road
        // Find a horizontal road near the edge of the city
        const halfCity = this.config.citySize / 2;
        const blockSize = this.config.blockSize;
        const roadWidth = this.config.roadWidth;
        
        // Position car on the southernmost horizontal road, facing north
        const roadZ = -halfCity + roadWidth / 2;
        this.mainCar.position.set(0, 0, roadZ);
        this.mainCar.rotation.y = Math.PI / 2; // Face north
        
        // Add chase camera (third-person view)
        this.chaseCam = new THREE.Object3D();
        this.chaseCam.position.set(0, 10, -15);
        this.mainCar.add(this.chaseCam);
        
        this.scene.add(this.mainCar);
      },
      
      // Create AI traffic vehicles
      createTraffic: function() {
        const carColors = [0x0000ff, 0x00ff00, 0xffff00, 0x00ffff, 0xff00ff, 0xffffff, 0x772200];
        
        for (let i = 0; i < this.config.trafficDensity; i++) {
          // Create traffic car
          const car = new THREE.Group();
          
          // Random car color
          const carColor = carColors[Math.floor(Math.random() * carColors.length)];
          
          // Car body
          const bodyGeometry = new THREE.BoxGeometry(3.5, 1.5, 6);
          const bodyMaterial = new THREE.MeshStandardMaterial({ color: carColor });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          body.position.y = 1.5;
          body.castShadow = true;
          car.add(body);
          
          // Car cabin
          const cabinGeometry = new THREE.BoxGeometry(3, 1, 3);
          const cabin = new THREE.Mesh(cabinGeometry, bodyMaterial);
          cabin.position.set(0, 2.5, 0);
          cabin.castShadow = true;
          car.add(cabin);
          
          // Wheels
          const wheelGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16);
          const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
          
          const wheelPositions = [
            [-1.8, 0.7, 1.5],  // Front left
            [1.8, 0.7, 1.5],   // Front right
            [-1.8, 0.7, -1.5], // Back left
            [1.8, 0.7, -1.5]   // Back right
          ];
          
          wheelPositions.forEach(position => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(...position);
            car.add(wheel);
          });
          
          // Position traffic cars on the roads
          const roadPosition = this.getRandomRoadPosition();
          car.position.set(roadPosition.x, 0, roadPosition.z);
          
          // Set initial orientation based on road direction
          // For left-side driving: horizontal roads - cars on left side go east, right side go west
          //                        vertical roads - cars on left side go north, right side go south
          let rotation = 0;
          if (roadPosition.isHorizontal) {
            // Horizontal road
            if (roadPosition.lane < 0) { // Left lane (negative offset)
              rotation = 0; // East
            } else {
              rotation = Math.PI; // West
            }
          } else {
            // Vertical road
            if (roadPosition.lane < 0) { // Left lane (negative offset)
              rotation = Math.PI / 2; // North
            } else {
              rotation = -Math.PI / 2; // South
            }
          }
          car.rotation.y = rotation;
          
          this.scene.add(car);
          
          // Add to cars array with additional data for movement
          this.state.cars.push({
            mesh: car,
            speed: 0.1 + Math.random() * 0.2,
            isHorizontal: roadPosition.isHorizontal,
            lane: roadPosition.lane, // Negative for left lane, positive for right lane
            currentIntersection: this.findClosestIntersection(roadPosition.x, roadPosition.z),
            targetIntersection: null,
            lastTurnDirection: null // To prevent U-turns
          });
        }
      },
      
      // Create trees around the city
      createTrees: function() {
        for (let i = 0; i < this.config.treeDensity; i++) {
          // Create tree at random position (avoiding roads)
          const x = (Math.random() - 0.5) * this.config.citySize * 1.8;
          const z = (Math.random() - 0.5) * this.config.citySize * 1.8;
          
          // Skip if position is on a road
          if (this.isOnRoad(x, z)) {
            continue;
          }
          
          // Tree trunk
          const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 4, 8);
          const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
          const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
          trunk.position.set(x, 2, z);
          trunk.castShadow = true;
          this.scene.add(trunk);
          
          // Tree foliage (using cone)
          const foliageGeometry = new THREE.ConeGeometry(3, 7, 8);
          const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x2e8b57 });
          const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
          foliage.position.set(x, 7, z);
          foliage.castShadow = true;
          this.scene.add(foliage);
          
          this.state.trees.push({ trunk, foliage });
        }
      },
      
      // Set up predefined destinations
      setupDestinations: function() {
        // Define some named destinations at specific coordinates
        this.destinations = [
          { name: "Downtown Plaza", x: 0, z: 0 },
          { name: "City Hall", x: this.config.blockSize, z: this.config.blockSize },
          { name: "Central Park", x: -this.config.blockSize, z: -this.config.blockSize },
          { name: "Shopping Mall", x: 2 * this.config.blockSize, z: -2 * this.config.blockSize },
          { name: "University", x: -2 * this.config.blockSize, z: 2 * this.config.blockSize },
          { name: "Train Station", x: 3 * this.config.blockSize, z: 0 },
          { name: "Hospital", x: 0, z: 3 * this.config.blockSize },
          { name: "Sports Arena", x: -3 * this.config.blockSize, z: -3 * this.config.blockSize }
        ];
        
        // Populate destination list
        const destinationList = document.getElementById('destinationList');
        this.destinations.forEach(dest => {
          const listItem = document.createElement('li');
          listItem.textContent = dest.name;
          listItem.addEventListener('click', () => {
            document.getElementById('destination').value = dest.name;
            this.handleDestinationSelection();
          });
          destinationList.appendChild(listItem);
        });
        
        // Add input event listener for destination search
        const destinationInput = document.getElementById('destination');
        destinationInput.addEventListener('input', () => {
          const searchTerm = destinationInput.value.toLowerCase();
          const filteredDestinations = this.destinations.filter(dest => 
            dest.name.toLowerCase().includes(searchTerm)
          );
          
          // Update destination list
          const destinationList = document.getElementById('destinationList');
          destinationList.innerHTML = '';
          
          filteredDestinations.forEach(dest => {
            const listItem = document.createElement('li');
            listItem.textContent = dest.name;
            listItem.addEventListener('click', () => {
              destinationInput.value = dest.name;
              this.handleDestinationSelection();
            });
            destinationList.appendChild(listItem);
          });
        });
      },
      
      // Handle destination selection
      handleDestinationSelection: function() {
        const destinationName = document.getElementById('destination').value;
        const destination = this.destinations.find(dest => dest.name === destinationName);
        
        if (destination) {
          // Ensure autonomous mode is activated
          this.state.isAutonomousMode = true;
          document.getElementById('toggleModeButton').textContent = 'Switch to Manual';
          document.getElementById('mode').textContent = 'Autonomous';
          document.getElementById('controls').style.display = 'none';
          
          this.state.currentDestination = destination;
          this.state.currentPath = this.findPath(
            this.findClosestIntersection(this.mainCar.position.x, this.mainCar.position.z),
            this.findClosestIntersection(destination.x, destination.z)
          );
          this.state.currentPathIndex = 0;
          this.state.isMoving = true;
          
          // Initialize car speed to ensure movement
          this.state.carSpeed = this.config.carSpeed * 0.5;
          
          console.log(`Navigating to ${destination.name}`);
          console.log('Path:', this.state.currentPath);
          console.log('Autonomous mode:', this.state.isAutonomousMode);
          console.log('Is moving:', this.state.isMoving);
          console.log('Initial car speed:', this.state.carSpeed);
          
          // Update mini-map with new path
          this.updateMiniMap();
          
          // Force the car to start moving immediately
          this.handleAutonomousDriving();
        } else {
          console.log('Destination not found');
        }
      },
      
      // Find the closest intersection to a position
      findClosestIntersection: function(x, z) {
        let closestIntersection = null;
        let closestDistance = Infinity;
        
        for (const intersection of this.state.intersections) {
          const distance = Math.sqrt(
            Math.pow(intersection.x - x, 2) + 
            Math.pow(intersection.z - z, 2)
          );
          
          if (distance < closestDistance) {
            closestDistance = distance;
            closestIntersection = intersection;
          }
        }
        
        return closestIntersection;
      },
      
      // Find a path between two intersections
      findPath: function(startIntersection, endIntersection) {
        // Simple A* pathfinding algorithm
        const openSet = [startIntersection];
        const closedSet = [];
        const cameFrom = new Map();
        
        // Cost from start to current node
        const gScore = new Map();
        gScore.set(this.getIntersectionKey(startIntersection), 0);
        
        // Estimated total cost from start to goal through current node
        const fScore = new Map();
        fScore.set(
          this.getIntersectionKey(startIntersection), 
          this.heuristic(startIntersection, endIntersection)
        );
        
        while (openSet.length > 0) {
          // Find node with lowest fScore
          let current = openSet[0];
          let lowestFScore = fScore.get(this.getIntersectionKey(current));
          let currentIndex = 0;
          
          for (let i = 1; i < openSet.length; i++) {
            const nodeKey = this.getIntersectionKey(openSet[i]);
            const score = fScore.get(nodeKey) || Infinity;
            
            if (score < lowestFScore) {
              lowestFScore = score;
              current = openSet[i];
              currentIndex = i;
            }
          }
          
          // If we reached the goal, reconstruct and return the path
          if (current.x === endIntersection.x && current.z === endIntersection.z) {
            const path = [current];
            let currentNode = current;
            
            while (cameFrom.has(this.getIntersectionKey(currentNode))) {
              currentNode = cameFrom.get(this.getIntersectionKey(currentNode));
              path.unshift(currentNode);
            }
            
            return path;
          }
          
          // Remove current from openSet and add to closedSet
          openSet.splice(currentIndex, 1);
          closedSet.push(current);
          
          // Get neighbors (adjacent intersections)
          const neighbors = this.getNeighbors(current);
          
          for (const neighbor of neighbors) {
            const neighborKey = this.getIntersectionKey(neighbor);
            
            // Skip if neighbor is in closedSet
            if (closedSet.some(node => 
              node.x === neighbor.x && node.z === neighbor.z
            )) {
              continue;
            }
            
            // Calculate tentative gScore
            const currentKey = this.getIntersectionKey(current);
            const tentativeGScore = (gScore.get(currentKey) || Infinity) + 
              this.distance(current, neighbor);
            
            // Add neighbor to openSet if not already there
            if (!openSet.some(node => node.x === neighbor.x && node.z === neighbor.z)) {
              openSet.push(neighbor);
            } else if (tentativeGScore >= (gScore.get(neighborKey) || Infinity)) {
              // This is not a better path
              continue;
            }
            
            // This path is the best so far, record it
            cameFrom.set(neighborKey, current);
            gScore.set(neighborKey, tentativeGScore);
            fScore.set(
              neighborKey, 
              tentativeGScore + this.heuristic(neighbor, endIntersection)
            );
          }
        }
        
        // No path found
        return [];
      },
      
      // Get a unique key for an intersection
      getIntersectionKey: function(intersection) {
        return `${intersection.x},${intersection.z}`;
      },
      
      // Heuristic function for A* (Manhattan distance)
      heuristic: function(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
      },
      
      // Calculate distance between two points
      distance: function(a, b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.z - b.z, 2));
      },
      
      // Get neighboring intersections
      getNeighbors: function(intersection) {
        const neighbors = [];
        const { blockSize, roadWidth } = this.config;
        const step = blockSize + roadWidth;
        
        // Check in all four directions
        const directions = [
          { dx: step, dz: 0 },  // East
          { dx: -step, dz: 0 }, // West
          { dx: 0, dz: step },  // North
          { dx: 0, dz: -step }  // South
        ];
        
        for (const dir of directions) {
          const neighborX = intersection.x + dir.dx;
          const neighborZ = intersection.z + dir.dz;
          
          // Check if this neighbor is a valid intersection
          const neighbor = this.state.intersections.find(
            i => i.x === neighborX && i.z === neighborZ
          );
          
          if (neighbor) {
            neighbors.push(neighbor);
          }
        }
        
        return neighbors;
      },
      
      // Get a random position on a road
      getRandomRoadPosition: function() {
        const halfCity = this.config.citySize / 2;
        const blockSize = this.config.blockSize;
        const roadWidth = this.config.roadWidth;
        const laneWidth = this.config.laneWidth;
        
        // Decide if horizontal or vertical road
        const isHorizontal = Math.random() > 0.5;
        
        // Decide which lane (left or right)
        // For left-side driving: negative offset is left lane, positive offset is right lane
        const lane = Math.random() > 0.5 ? -1 : 1;
        const laneOffset = lane * (laneWidth / 2);
        
        if (isHorizontal) {
          // Horizontal road (constant z)
          const roadZ = Math.floor(Math.random() * (halfCity * 2 / (blockSize + roadWidth))) * (blockSize + roadWidth) - halfCity;
          const roadX = (Math.random() - 0.5) * this.config.citySize * 2;
          return { x: roadX, z: roadZ + laneOffset, isHorizontal: true, lane: lane };
        } else {
          // Vertical road (constant x)
          const roadX = Math.floor(Math.random() * (halfCity * 2 / (blockSize + roadWidth))) * (blockSize + roadWidth) - halfCity;
          const roadZ = (Math.random() - 0.5) * this.config.citySize * 2;
          return { x: roadX + laneOffset, z: roadZ, isHorizontal: false, lane: lane };
        }
      },
      
      // Check if a position is on a road
      isOnRoad: function(x, z) {
        const halfCity = this.config.citySize / 2;
        const blockSize = this.config.blockSize;
        const roadWidth = this.config.roadWidth;
        
        // Check if on horizontal road
        for (let roadZ = -halfCity; roadZ <= halfCity; roadZ += blockSize + roadWidth) {
          if (Math.abs(z - roadZ) < roadWidth / 2) {
            return true;
          }
        }
        
        // Check if on vertical road
        for (let roadX = -halfCity; roadX <= halfCity; roadX += blockSize + roadWidth) {
          if (Math.abs(x - roadX) < roadWidth / 2) {
            return true;
          }
        }
        
        return false;
      },
      
      // Handle autonomous driving
      handleAutonomousDriving: function() {
        if (!this.state.isAutonomousMode || !this.state.isMoving || !this.state.currentPath.length) {
          // Debug why autonomous driving is not working
          if (this.state.currentDestination) {
            console.log('Autonomous driving check:',
              'isAutonomousMode:', this.state.isAutonomousMode,
              'isMoving:', this.state.isMoving,
              'pathLength:', this.state.currentPath ? this.state.currentPath.length : 0
            );
          }
          return;
        }
        
        // Get current target intersection
        const targetIntersection = this.state.currentPath[this.state.currentPathIndex];
        
        // Calculate direction to target
        const dx = targetIntersection.x - this.mainCar.position.x;
        const dz = targetIntersection.z - this.mainCar.position.z;
        const distanceToTarget = Math.sqrt(dx * dx + dz * dz);
        
        // If we're close enough to the current target, move to the next one
        if (distanceToTarget < 5) {
          this.state.currentPathIndex++;
          
          // If we've reached the end of the path, stop
          if (this.state.currentPathIndex >= this.state.currentPath.length) {
            this.state.isMoving = false;
            this.state.carSpeed = 0;
            document.getElementById('speed').textContent = '0';
            console.log('Destination reached!');
            return;
          }
        }
        
        // Calculate target angle
        const targetAngle = Math.atan2(dx, dz);
        
        // Smoothly rotate towards target
        let currentAngle = this.mainCar.rotation.y;
        const angleDiff = this.normalizeAngle(targetAngle - currentAngle);
        
        // Rotate car
        if (Math.abs(angleDiff) > 0.05) {
          // Slow down for turns
          this.state.carSpeed = Math.max(this.state.carSpeed * 0.95, this.config.carSpeed * 0.3);
          
          // Rotate towards target
          this.mainCar.rotation.y += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.05);
        } else {
          // Accelerate on straight paths
          this.state.carSpeed = Math.min(this.state.carSpeed + 0.01, this.config.carSpeed);
        }
        
        // Ensure minimum speed when in autonomous mode
        if (this.state.carSpeed < 0.05) {
          this.state.carSpeed = 0.05;
        }
        
        // Move car forward
        const newX = this.mainCar.position.x + Math.sin(this.mainCar.rotation.y) * this.state.carSpeed;
        const newZ = this.mainCar.position.z + Math.cos(this.mainCar.rotation.y) * this.state.carSpeed;
        
        // Check if the new position is on a road
        if (this.isOnRoad(newX, newZ)) {
          // Determine if we're on a horizontal or vertical road
          const roadInfo = this.getRoadInfo(newX, newZ);
          
          if (roadInfo) {
            // Adjust position to stay in the left lane
            let adjustedX = newX;
            let adjustedZ = newZ;
            
            if (roadInfo.isHorizontal) {
              // Horizontal road - adjust Z position
              // For left-side driving: if going east (rotation ~= 0), stay on north side (negative offset)
              //                        if going west (rotation ~= PI), stay on south side (positive offset)
              const targetLaneOffset = (Math.abs(this.normalizeAngle(this.mainCar.rotation.y)) < Math.PI/2) ? 
                -this.config.laneWidth/2 : this.config.laneWidth/2;
              
              // Gradually adjust to the correct lane
              const currentOffset = newZ - roadInfo.roadCenter;
              if (Math.abs(currentOffset - targetLaneOffset) > 0.2) {
                adjustedZ = newZ + (targetLaneOffset - currentOffset) * 0.05;
              }
            } else {
              // Vertical road - adjust X position
              // For left-side driving: if going north (rotation ~= PI/2), stay on west side (negative offset)
              //                        if going south (rotation ~= -PI/2), stay on east side (positive offset)
              const targetLaneOffset = (this.mainCar.rotation.y > 0) ? 
                -this.config.laneWidth/2 : this.config.laneWidth/2;
              
              // Gradually adjust to the correct lane
              const currentOffset = newX - roadInfo.roadCenter;
              if (Math.abs(currentOffset - targetLaneOffset) > 0.2) {
                adjustedX = newX + (targetLaneOffset - currentOffset) * 0.05;
              }
            }
            
            // Update position
            this.mainCar.position.x = adjustedX;
            this.mainCar.position.z = adjustedZ;
          } else {
            // If not on a specific road, just move forward
            this.mainCar.position.x = newX;
            this.mainCar.position.z = newZ;
          }
        } else {
          // If we would go off-road, slow down and don't move
          this.state.carSpeed *= 0.9;
        }
        
        // Update speedometer
        document.getElementById('speed').textContent = Math.round(this.state.carSpeed * 50);
      },
      
      // Get information about the road at a specific position
      getRoadInfo: function(x, z) {
        const halfCity = this.config.citySize / 2;
        const blockSize = this.config.blockSize;
        const roadWidth = this.config.roadWidth;
        
        // Check horizontal roads
        for (let roadZ = -halfCity; roadZ <= halfCity; roadZ += blockSize + roadWidth) {
          if (Math.abs(z - roadZ) < roadWidth / 2) {
            return {
              isHorizontal: true,
              roadCenter: roadZ
            };
          }
        }
        
        // Check vertical roads
        for (let roadX = -halfCity; roadX <= halfCity; roadX += blockSize + roadWidth) {
          if (Math.abs(x - roadX) < roadWidth / 2) {
            return {
              isHorizontal: false,
              roadCenter: roadX
            };
          }
        }
        
        return null; // Not on a road
      },
      
      // Handle manual driving
      handleManualDriving: function() {
        if (this.state.isAutonomousMode) {
          return;
        }
        
        // Handle forward/backward movement
        if (this.state.keyStates['ArrowUp']) {
          this.state.carSpeed = Math.min(this.state.carSpeed + 0.01, this.config.carSpeed);
          this.mainCar.position.x += Math.sin(this.mainCar.rotation.y) * this.state.carSpeed;
          this.mainCar.position.z += Math.cos(this.mainCar.rotation.y) * this.state.carSpeed;
        } else if (this.state.keyStates['ArrowDown']) {
          this.state.carSpeed = Math.min(this.state.carSpeed + 0.01, this.config.carSpeed * 0.5);
          this.mainCar.position.x -= Math.sin(this.mainCar.rotation.y) * this.state.carSpeed;
          this.mainCar.position.z -= Math.cos(this.mainCar.rotation.y) * this.state.carSpeed;
        } else {
          // Slow down when no keys are pressed
          this.state.carSpeed *= 0.95;
        }
        
        // Handle turning
        if (this.state.keyStates['ArrowLeft']) {
          this.mainCar.rotation.y += 0.03;
        }
        if (this.state.keyStates['ArrowRight']) {
          this.mainCar.rotation.y -= 0.03;
        }
        
        // Update speedometer
        document.getElementById('speed').textContent = Math.round(this.state.carSpeed * 50);
      },
      
      // Normalize angle to [-PI, PI]
      normalizeAngle: function(angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
      },
      
      // Update traffic vehicles
      updateTraffic: function() {
        for (const car of this.state.cars) {
          // If car has no target, find a new one
          if (!car.targetIntersection) {
            const neighbors = this.getNeighbors(car.currentIntersection);
            if (neighbors.length > 0) {
              // Filter out neighbors that would cause a U-turn
              let validNeighbors = neighbors;
              if (car.lastTurnDirection) {
                validNeighbors = neighbors.filter(neighbor => {
                  const dx = neighbor.x - car.currentIntersection.x;
                  const dz = neighbor.z - car.currentIntersection.z;
                  
                  // Don't go back the way we came (avoid U-turns)
                  if (car.lastTurnDirection === 'east' && dx < 0) return false;
                  if (car.lastTurnDirection === 'west' && dx > 0) return false;
                  if (car.lastTurnDirection === 'north' && dz < 0) return false;
                  if (car.lastTurnDirection === 'south' && dz > 0) return false;
                  
                  return true;
                });
                
                // If no valid neighbors, allow U-turns
                if (validNeighbors.length === 0) {
                  validNeighbors = neighbors;
                }
              }
              
              // Choose a random valid neighbor
              car.targetIntersection = validNeighbors[Math.floor(Math.random() * validNeighbors.length)];
              
              // Record turn direction
              const dx = car.targetIntersection.x - car.currentIntersection.x;
              const dz = car.targetIntersection.z - car.currentIntersection.z;
              
              if (dx > 0) car.lastTurnDirection = 'east';
              else if (dx < 0) car.lastTurnDirection = 'west';
              else if (dz > 0) car.lastTurnDirection = 'north';
              else if (dz < 0) car.lastTurnDirection = 'south';
            }
          }
          
          if (car.targetIntersection) {
            // Calculate direction to target
            const dx = car.targetIntersection.x - car.mesh.position.x;
            const dz = car.targetIntersection.z - car.mesh.position.z;
            const distanceToTarget = Math.sqrt(dx * dx + dz * dz);
            
            // If we're close enough to the target, set it as current and find a new target
            if (distanceToTarget < 5) {
              car.currentIntersection = car.targetIntersection;
              car.targetIntersection = null;
              continue;
            }
            
            // Calculate target angle
            const targetAngle = Math.atan2(dx, dz);
            
            // Smoothly rotate towards target
            let currentAngle = car.mesh.rotation.y;
            const angleDiff = this.normalizeAngle(targetAngle - currentAngle);
            
            // Rotate car
            if (Math.abs(angleDiff) > 0.05) {
              car.mesh.rotation.y += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.03);
            }
            
            // Calculate new position
            const newX = car.mesh.position.x + Math.sin(car.mesh.rotation.y) * car.speed;
            const newZ = car.mesh.position.z + Math.cos(car.mesh.rotation.y) * car.speed;
            
            // Check if the new position is on a road
            if (this.isOnRoad(newX, newZ)) {
              // Determine if we're on a horizontal or vertical road
              const roadInfo = this.getRoadInfo(newX, newZ);
              
              if (roadInfo) {
                // Adjust position to stay in the correct lane
                let adjustedX = newX;
                let adjustedZ = newZ;
                
                if (roadInfo.isHorizontal) {
                  // Horizontal road - adjust Z position
                  // For left-side driving: if going east (rotation ~= 0), stay on north side (negative offset)
                  //                        if going west (rotation ~= PI), stay on south side (positive offset)
                  const targetLaneOffset = (Math.abs(this.normalizeAngle(car.mesh.rotation.y)) < Math.PI/2) ? 
                    -this.config.laneWidth/2 : this.config.laneWidth/2;
                  
                  // Gradually adjust to the correct lane
                  const currentOffset = newZ - roadInfo.roadCenter;
                  if (Math.abs(currentOffset - targetLaneOffset) > 0.2) {
                    adjustedZ = newZ + (targetLaneOffset - currentOffset) * 0.05;
                  }
                } else {
                  // Vertical road - adjust X position
                  // For left-side driving: if going north (rotation ~= PI/2), stay on west side (negative offset)
                  //                        if going south (rotation ~= -PI/2), stay on east side (positive offset)
                  const targetLaneOffset = (car.mesh.rotation.y > 0) ? 
                    -this.config.laneWidth/2 : this.config.laneWidth/2;
                  
                  // Gradually adjust to the correct lane
                  const currentOffset = newX - roadInfo.roadCenter;
                  if (Math.abs(currentOffset - targetLaneOffset) > 0.2) {
                    adjustedX = newX + (targetLaneOffset - currentOffset) * 0.05;
                  }
                }
                
                // Update position
                car.mesh.position.x = adjustedX;
                car.mesh.position.z = adjustedZ;
              } else {
                // If not on a specific road, just move forward
                car.mesh.position.x = newX;
                car.mesh.position.z = newZ;
              }
            }
            
            // Check for collision with main car
            const distanceToMainCar = this.distance(
              { x: car.mesh.position.x, z: car.mesh.position.z },
              { x: this.mainCar.position.x, z: this.mainCar.position.z }
            );
            
            // Slow down if too close to main car
            if (distanceToMainCar < 10) {
              car.speed = Math.max(car.speed * 0.9, 0.01);
            } else {
              car.speed = Math.min(car.speed + 0.001, 0.1 + Math.random() * 0.2);
            }
            
            // Check for collisions with other traffic cars
            for (const otherCar of this.state.cars) {
              if (otherCar === car) continue;
              
              const distanceToOtherCar = this.distance(
                { x: car.mesh.position.x, z: car.mesh.position.z },
                { x: otherCar.mesh.position.x, z: otherCar.mesh.position.z }
              );
              
              if (distanceToOtherCar < 8) {
                car.speed = Math.max(car.speed * 0.8, 0.01);
                break;
              }
            }
          }
        }
      },
      
      // Set up the mini-map
      setupMiniMap: function() {
        this.miniMapCanvas = document.getElementById('miniMapCanvas');
        this.miniMapContext = this.miniMapCanvas.getContext('2d');
        
        // Set canvas size
        this.miniMapCanvas.width = 200;
        this.miniMapCanvas.height = 200;
        
        // Initial mini-map render
        this.updateMiniMap();
      },
      
      // Update the mini-map
      updateMiniMap: function() {
        const ctx = this.miniMapContext;
        const mapSize = 200;
        const citySize = this.config.citySize;
        const scale = mapSize / (citySize * 2);
        
        // Clear the canvas
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, mapSize, mapSize);
        
        // Draw roads
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        
        const halfCity = citySize / 2;
        const blockSize = this.config.blockSize;
        const roadWidth = this.config.roadWidth;
        
        // Draw horizontal roads
        for (let z = -halfCity; z <= halfCity; z += blockSize + roadWidth) {
          const mapZ = (z + halfCity) * scale;
          ctx.beginPath();
          ctx.moveTo(0, mapZ);
          ctx.lineTo(mapSize, mapZ);
          ctx.stroke();
        }
        
        // Draw vertical roads
        for (let x = -halfCity; x <= halfCity; x += blockSize + roadWidth) {
          const mapX = (x + halfCity) * scale;
          ctx.beginPath();
          ctx.moveTo(mapX, 0);
          ctx.lineTo(mapX, mapSize);
          ctx.stroke();
        }
        
        // Draw buildings (as small rectangles)
        ctx.fillStyle = '#666';
        for (const building of this.state.buildings) {
          const mapX = (building.position.x + halfCity) * scale;
          const mapZ = (building.position.z + halfCity) * scale;
          const size = 3;
          ctx.fillRect(mapX - size/2, mapZ - size/2, size, size);
        }
        
        // Draw path if available
        if (this.state.currentPath && this.state.currentPath.length > 0) {
          ctx.strokeStyle = '#4285f4';
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          // Start from car position
          const startX = (this.mainCar.position.x + halfCity) * scale;
          const startZ = (this.mainCar.position.z + halfCity) * scale;
          ctx.moveTo(startX, startZ);
          
          // Draw path through all waypoints
          for (const point of this.state.currentPath) {
            const pointX = (point.x + halfCity) * scale;
            const pointZ = (point.z + halfCity) * scale;
            ctx.lineTo(pointX, pointZ);
          }
          
          ctx.stroke();
        }
        
        // Draw destination if available
        if (this.state.currentDestination) {
          const destX = (this.state.currentDestination.x + halfCity) * scale;
          const destZ = (this.state.currentDestination.z + halfCity) * scale;
          
          // Draw destination marker (star shape)
          ctx.fillStyle = '#ffcc00';
          ctx.beginPath();
          this.drawStar(ctx, destX, destZ, 5, 3, 6);
          ctx.fill();
        }
        
        // Draw main car (as a triangle pointing in the direction of travel)
        const carX = (this.mainCar.position.x + halfCity) * scale;
        const carZ = (this.mainCar.position.z + halfCity) * scale;
        const carAngle = this.mainCar.rotation.y;
        
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.save();
        ctx.translate(carX, carZ);
        ctx.rotate(-carAngle); // Negative because z is up in 3D but down in 2D
        ctx.moveTo(0, -4);
        ctx.lineTo(-3, 4);
        ctx.lineTo(3, 4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Draw other cars (as small dots)
        ctx.fillStyle = '#00ff00';
        for (const car of this.state.cars) {
          const otherCarX = (car.mesh.position.x + halfCity) * scale;
          const otherCarZ = (car.mesh.position.z + halfCity) * scale;
          ctx.beginPath();
          ctx.arc(otherCarX, otherCarZ, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      },
      
      // Helper function to draw a star shape
      drawStar: function(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        let step = Math.PI / spikes;
        
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerRadius;
          y = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(x, y);
          rot += step;
          
          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(x, y);
          rot += step;
        }
        
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
      },
      
      // Check for collisions with buildings and other cars
      checkCollisions: function() {
        // Check for collisions with buildings
        for (const building of this.state.buildings) {
          const distanceToBuilding = this.distance(
            { x: this.mainCar.position.x, z: this.mainCar.position.z },
            { x: building.position.x, z: building.position.z }
          );
          
          // Get building dimensions
          const buildingWidth = building.geometry.parameters.width;
          const buildingDepth = building.geometry.parameters.depth;
          const collisionThreshold = Math.max(buildingWidth, buildingDepth) / 2 + 4; // Car width/length is about 4
          
          if (distanceToBuilding < collisionThreshold) {
            // Slow down the car
            this.state.carSpeed *= 0.8;
            
            // Push car away from building slightly
            const pushDirection = {
              x: this.mainCar.position.x - building.position.x,
              z: this.mainCar.position.z - building.position.z
            };
            
            // Normalize push direction
            const pushLength = Math.sqrt(pushDirection.x * pushDirection.x + pushDirection.z * pushDirection.z);
            if (pushLength > 0) {
              pushDirection.x /= pushLength;
              pushDirection.z /= pushLength;
              
              // Apply push
              this.mainCar.position.x += pushDirection.x * 0.2;
              this.mainCar.position.z += pushDirection.z * 0.2;
            }
          }
        }
        
        // Check for collisions with other cars
        for (const car of this.state.cars) {
          const distanceToCar = this.distance(
            { x: this.mainCar.position.x, z: this.mainCar.position.z },
            { x: car.mesh.position.x, z: car.mesh.position.z }
          );
          
          if (distanceToCar < 6) {
            // Slow down the car
            this.state.carSpeed *= 0.8;
            
            // Push cars away from each other slightly
            const pushDirection = {
              x: this.mainCar.position.x - car.mesh.position.x,
              z: this.mainCar.position.z - car.mesh.position.z
            };
            
            // Normalize push direction
            const pushLength = Math.sqrt(pushDirection.x * pushDirection.x + pushDirection.z * pushDirection.z);
            if (pushLength > 0) {
              pushDirection.x /= pushLength;
              pushDirection.z /= pushLength;
              
              // Apply push to main car
              this.mainCar.position.x += pushDirection.x * 0.2;
              this.mainCar.position.z += pushDirection.z * 0.2;
              
              // Apply opposite push to traffic car
              car.mesh.position.x -= pushDirection.x * 0.1;
              car.mesh.position.z -= pushDirection.z * 0.1;
            }
          }
        }
      },
      
      // Animation loop
      animate: function() {
        requestAnimationFrame(this.animate.bind(this));
        
        // Handle driving based on mode
        if (this.state.isAutonomousMode) {
          // Debug autonomous mode status every 100 frames
          if (this.state.frameCount % 100 === 0 && this.state.currentDestination) {
            console.log('Autonomous mode active:', 
              'isMoving:', this.state.isMoving, 
              'pathIndex:', this.state.currentPathIndex,
              'carSpeed:', this.state.carSpeed
            );
          }
          this.handleAutonomousDriving();
        } else {
          this.handleManualDriving();
        }
        
        // Update frame counter
        this.state.frameCount = (this.state.frameCount || 0) + 1;
        
        // Update traffic
        this.updateTraffic();
        
        // Check for collisions
        this.checkCollisions();
        
        // Update mini-map
        this.updateMiniMap();
        
        // Update camera position to follow car
        this.camera.position.copy(this.chaseCam.getWorldPosition(new THREE.Vector3()));
        this.camera.lookAt(this.mainCar.position);
        
        // Render scene
        this.renderer.render(this.scene, this.camera);
      }
    };
    
    // Initialize the application when the page loads
    window.addEventListener('load', () => {
      App.init();
    });
  </script>
</body>
</html>